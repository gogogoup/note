# Javascript

[[toc]]

## 数据类型
#### 分类  
基本数据类型和引用类型

#### 1. 基本数据类型  
  null, undefined, boolean, number, string
  * 基本数据类型是存在栈中
  * 基本数据类型是不可变的
  * 基本数据类型的比较是值的比较
    * 比较是最好使用‘===’防止进行类型转换

#### 2. 引用类型  
  object
* 放在堆内存中  
  表示Object的变量其实是一个存在栈中的指针，指向堆内存的地址

* 值可变

* 引用类型的比较是引用的比较  
  是比较指针是否指向同一个内存地址

* 传值和传址
  * 基本类型的赋值，是在内存中开辟新的一段栈内存，是传值
  * 引用类型的赋值是传址，只将变量（指针）指向赋值的对象，因此，改变两个变量指向同一个内存地址，一个发生了修改之后另一个也会修改
  
* 赋值，浅拷贝，深拷贝
  * ![](/note/2019-06-19-13-40-11.png)
  * 简单点总结一下就是：
  * 赋值是将新的变量指向原来引用对象，因此新的变量与原来指向相同内存地址的变量是完全相同的，改变任何一个都会导致别的也发生改变
  * 浅拷贝是将引用对象的第一层属性做了复制，如果属性的值是基本类型则是赋值，如果是引用类型则是传址，因此如果改变引用类型的属性值，原对象也会同时发生改变
  * 深拷贝是将引用对象的属性，子属性（子对象），均进行拷贝，这样即使属性值是引用类型，也会开辟新的内存地址存储，不会发生同时改变的情况
  
* 浅拷贝和深拷贝的实现
  * 浅拷贝：遍历对象属性，赋值
  * 深拷贝：遍历对象属性，判断属性值是不是引用类型，是的话递归调用后赋值，不是的话直接赋值


## 扫雷原理
来源是codepen上一个扫雷项目：[codepen](https://codepen.io/creme/pen/EqeXNJ)  
整理了下实现原理：

最麻烦的几个地方：
1. 怎么随机放置炸弹
2. 怎么做出点击某些格子，瞬间展开一大片的效果
3. 怎么确定某些点四周的雷的个数

过程：
1. 创建n*n的格子
2. 遍历格子，此时进行n^2次遍历，每个遍历中，利用`Math.random() < bombFrequency(0)`来确定当前格子是否表示为炸弹所在格子
3. 如果是炸弹，将该格子位置塞到表示炸弹位置的数组A中，将该格子周围8个格子（如果炸弹位置在边界则小于八个）的位置塞到一个数组B中
4. 将左键单击检查格子炸弹情况的事件1和右键单击标记格子是炸弹的事件2，绑定在每个格子上
4. 继续标记下一个格子，直到标记完成
5. 遍历数组B，每次出现一个格子位置，就在该格子上标记当前格子周围的炸弹数目+1
6. 到这一步，就完成了格子的布局和格子周围炸弹数量的标记
7. 事件1的处理：
    * 获取当前格子的位置坐标，检查是否在炸弹列表中，如果是，就endGame；如果不是，继续
    * 检查当前格子上周围炸弹的数量，在点击完成后标记
    * 如果当前格子周围没有炸弹，就模拟点击周围8个位置的点，此时，如果这八个点中有和当前格子相同的情况，即周围没有格子，就会递归的再次模拟点击该格子周围的八个空白点，以此实现点击空白格子展开一大片的效果
8. 获胜的处理：每次点击了格子，就去检查一下所有的格子是否被正确的标记或者点击，如果有炸弹的位置，没有被标记为checked，就可以判断为未检查，所以不获胜


## 虚拟dom和diff算法

### 虚拟dom树
是现在前端框架里面广泛在用的一个dom操作的方式。跟传统的jq相比，这个不会直接去操作对应的dom节点，而是把整个dom结构抽象成一个js中的object对象，在数据更新的时候diff一下新旧对象，再把object渲染成完整的dom结构  
这个优缺点很明显：
  1. 能保证性能下限，因为不管多少个节点更新，都只会做一次render，但这也是性能瓶颈，因为如果只有一个节点做了更改，整个页面都会进行一次重绘，在一些要求比较高的应用，比如vscode，他们就会直接操作dom，来代替部分虚拟dom的渲染
  2. 兼容性更好，因为全是js的对象来保存dom结构信息，所以兼容性的处理统一由一个render函数处理了，贼拉方便
  3. 不需要操作dom了，会把开发者的注意力集中到处理数据和逻辑上，效率会更高
  4. 因为出现了虚拟dom的渲染方式，所以nodejs做服务端渲染，变得更加方便，不再做模版解析。而且这个也可以跨平台，比如小程序，微信自定义了一种类似html的wxml，在render函数中，修改对应生成的节点类型，就可以兼容到小程序。

![](/note/2019-08-20-11-18-06.png)  
所以更新问题就会被转换成了两颗树的比较问题。标准的diff算法的复杂度O(n^3)，在dom树上，可以做很多优化，最后可以降到O(n)  
主要是：不同类型的元素产生不同的树；同一层级的一组子节点可以通过唯一的key区分
![](/note/2019-08-20-11-18-26.png)  
也就是，只会对相同颜色的dom节点进行比较；如果节点不存在了，该节点和它的子节点都被删除，不做进一步的比较


### diff算法
![](/note/2019-08-20-11-20-42.png)
并不是移动a和它的子节点，而是：createA，createB，createC，deleteA（old）  
抽象完成之后，变成这种结构：
![](/note/2019-08-20-12-53-03.png)  

1. 先比较最外层节点，其实是比较抽象时节点的key和sel，如果这俩都不一样，就直接替换了
2. 上一步如果相同，则会把旧节点的el赋值到新节点上，让它指向同一个对象，保证对对象的修改会同步到新节点上。然后继续比较，如果新旧对象的引用相同，也就是内存地址都相同，就是相同的节点，可以跳过了；如果不同，再比较文本，如果文本相同，比较子节点
3. 子节点的情况再分成：新的有，旧的没有，就在老节点上添加；如果新节点没有，旧的有，就删除；如果都有，做更新
4. ![](/note/2019-08-20-12-54-52.png)
5. 更新过程：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式：
    * 新的start和旧的start，相同时不进行dom移动
    * 新的end和旧的end，相同时不进行dom移动
    * 新的start和旧的end，相同时，说明旧的end跑到start前
    * 新的end和旧的start，相同时，说明旧的start跑到end后
6. 在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。
7. 结束时分成两种
    * oldStartIdx > oldEndIdx：newStartIdx和newEndIdx之间就是新增的了，直接插入
    * newStartIdx > newEndIdx：oldStartIdx和oldEndIdx之间就是需要删除的


## js存储数据到图片

问题来源于自己做的chromeExtension工具中，受限于Chrome提供的api中没有文件写入的相关api，不能存储todo的数据。而直接存储数据，总觉得不够帅气。  
偶然看到有选手利用图片压缩数据的思路，就尝试把todo数据塞到图片，然后提供下载和解析功能，完成数据的导出导入。具体思路是：

### 将字符串数据转成像素值
因为每个像素值的四个通道值范围是0-255，也就是8位二进制值，所以需要将字符串的每个字符做utf8编码，然后转十进制，得到0-255之间的值。  
  - 如果字符是单字节，直接获取unicode码点  
  - 如果是多字节字符，有两种方式  
    - 获取到字符unicode，照着utf8编码规则，几个if下去，判断出范围，拆成对应的多个字节
    - `encodeURI`会对传入字符做utf8编码转义，%作为间隔符号，得到字符拆成多字节后的16进制值，然后parseInt("xxx", 16)获取到10进制数据

### 使用转换后的像素数据，绘图

#### alpha通道不能传值
单个像素的四个通道，如果都设置了，在生成图片后再解析，会有偏差。  
原因是：浏览器对像素的合成做`premultiplied alpha`处理，会在合成的之前，对像素的rgb通道乘以透明度
  - 举例：两个像素的图片，左边是纯红色rgba(255,0,0,1)，右边是有透明度的绿色rgba(0,255,0,0.1)。当把图片缩放到1x1的时候，最后合成的像素是左右两个像素插值的结果，也就是各个通道值相加除2
    - straignt alpha： rgba(127,127,0,0.55)
    - premultiplied alpha: rgba(127,25,0,0.55)
    - ![](/note/2019-12-17-14-22-04.png)
    - straignt alpha的绿色会更重，因为在插值的时候没有乘透明度，而透明度是会影响所以通道值的，这样会导致像素插值的时候失真  
没有办法修改浏览器的默认行为。解决方式是把alpha通道值全部设成255，也就是alpha值在公式中是1，不会导致偏差
- 所以，需要将字符串的数据按每三个一个像素的方式进行存储
- 字符串数据的长度可能不能被三整除，需要补位。具体做法是，补位的通道值都设置成255。将像素数据的第一个值，定义为消息位，r通道值为补位像素个数。解码的时候读了第一个像素的r通道值后存下来，到遍历的最后一个时，只取对应的有效值就行。

#### canvas绘图的尺寸设定
canvas生成图片的要求是`传入的像素素组长度 = 4 * 图片宽度 * 图片高度`。  
所以预设一个最大的图片宽度，然后穷举，从最大开始依次减小，长度/4/宽度，得到的是个整数，就认为是个合法的宽高了。  
致命缺点：如果长度刚好是个质数，就莫法了，只能手动加个像素，并且在第一个像素的g通道标示。  
利用canvas绘图api，传入图片信息，设定的尺寸，进行绘图

### 解析生成的图片为字符串
- 获取上传图片的二进制值，
  - 添加上传事件的监听，获取到file对象，传入fileReader
    - 如果是文本/json，readAsText；
    - 如果是图片，readAsDataURL，
  - 传入新增加img对象中，监听onload事件，读url，获取到上传图片的base64值
  - 传入canvas的drawImage，读canvas数据，得到二进制值
- 像素值转字符串
  - PixToData
    ```js
    PixToData(pixList) {
      let lastCount;
      let res = [];
      for (let i = 0; i < pixList.length; i += 4) {
        if (i === 0) {
          // 补位像素的提示像素
          lastCount = pixList[i]
        } else if (i === pixList.length - 4 && lastCount !== 0) {
          for (let j = 0; j < lastCount; j++) {
            res.push(pixList[i + j]);
          }
        } else {
          res.push(pixList[i], pixList[i + 1], pixList[i + 2]);
        }
      }
      return res;
    }
    ```
  - Utf8ArrayToString
    ```js
    Utf8ArrayToString(list) {
      let res = "";
      for (let i = 0; i < list.length; i++) {
        let e = list[i];
        let byte = e.toString(2);
        if (byte.length < 8) {
          // 单字节
          res += String.fromCodePoint(e);
        } else {
          let count = 0;
          // 根据第一个字节的二进制编码中首位1的个数，获取到该字符需要几个字节
          for (let j = 0; j < byte.length; j++) {
            const b = byte[j];
            if (b === "1") {
              continue
            } else {
              count = j;
              break;
            }
          }
          if (count > 0) {
            let tmp = "";
            for (let k = 0; k < count; k++) {
              tmp += `%${list[i + k].toString(16)}`
            }
            !!tmp && (res += decodeURI(tmp));
            i += (count - 1)
          } else {
            res += String.fromCodePoint(e);
          }
        }
      }
      return res;
    }
    ```
    - 把每个数据转成二进制，补到8位
    - 根据字节的首位1的数量，获取到该字符是由几个字节组成
    - 把对应的字转成16进制，拼到一起，`decodeURI`
    - 单字节直接`fromCodePoint`