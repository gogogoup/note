# Javascript

[[toc]]

## 数据类型
#### 分类  
基本数据类型和引用类型

#### 1. 基本数据类型  
  null, undefined, boolean, number, string
  * 基本数据类型是存在栈中
  * 基本数据类型是不可变的
  * 基本数据类型的比较是值的比较
    * 比较是最好使用‘===’防止进行类型转换

#### 2. 引用类型  
  object
* 放在堆内存中  
  表示Object的变量其实是一个存在栈中的指针，指向堆内存的地址

* 值可变

* 引用类型的比较是引用的比较  
  是比较指针是否指向同一个内存地址

* 传值和传址
  * 基本类型的赋值，是在内存中开辟新的一段栈内存，是传值
  * 引用类型的赋值是传址，只将变量（指针）指向赋值的对象，因此，改变两个变量指向同一个内存地址，一个发生了修改之后另一个也会修改
  
* 赋值，浅拷贝，深拷贝
  * ![](/note/2019-06-19-13-40-11.png)
  * 简单点总结一下就是：
  * 赋值是将新的变量指向原来引用对象，因此新的变量与原来指向相同内存地址的变量是完全相同的，改变任何一个都会导致别的也发生改变
  * 浅拷贝是将引用对象的第一层属性做了复制，如果属性的值是基本类型则是赋值，如果是引用类型则是传址，因此如果改变引用类型的属性值，原对象也会同时发生改变
  * 深拷贝是将引用对象的属性，子属性（子对象），均进行拷贝，这样即使属性值是引用类型，也会开辟新的内存地址存储，不会发生同时改变的情况
  
* 浅拷贝和深拷贝的实现
  * 浅拷贝：遍历对象属性，赋值
  * 深拷贝：遍历对象属性，判断属性值是不是引用类型，是的话递归调用后赋值，不是的话直接赋值


## 扫雷原理
来源是codepen上一个扫雷项目：[codepen](https://codepen.io/creme/pen/EqeXNJ)  
整理了下实现原理：

最麻烦的几个地方：
1. 怎么随机放置炸弹
2. 怎么做出点击某些格子，瞬间展开一大片的效果
3. 怎么确定某些点四周的雷的个数

过程：
1. 创建n*n的格子
2. 遍历格子，此时进行n^2次遍历，每个遍历中，利用`Math.random() < bombFrequency(0)`来确定当前格子是否表示为炸弹所在格子
3. 如果是炸弹，将该格子位置塞到表示炸弹位置的数组A中，将该格子周围8个格子（如果炸弹位置在边界则小于八个）的位置塞到一个数组B中
4. 将左键单击检查格子炸弹情况的事件1和右键单击标记格子是炸弹的事件2，绑定在每个格子上
4. 继续标记下一个格子，直到标记完成
5. 遍历数组B，每次出现一个格子位置，就在该格子上标记当前格子周围的炸弹数目+1
6. 到这一步，就完成了格子的布局和格子周围炸弹数量的标记
7. 事件1的处理：
    * 获取当前格子的位置坐标，检查是否在炸弹列表中，如果是，就endGame；如果不是，继续
    * 检查当前格子上周围炸弹的数量，在点击完成后标记
    * 如果当前格子周围没有炸弹，就模拟点击周围8个位置的点，此时，如果这八个点中有和当前格子相同的情况，即周围没有格子，就会递归的再次模拟点击该格子周围的八个空白点，以此实现点击空白格子展开一大片的效果
8. 获胜的处理：每次点击了格子，就去检查一下所有的格子是否被正确的标记或者点击，如果有炸弹的位置，没有被标记为checked，就可以判断为未检查，所以不获胜


## 虚拟dom和diff算法

### 虚拟dom树
是现在前端框架里面广泛在用的一个dom操作的方式。跟传统的jq相比，这个不会直接去操作对应的dom节点，而是把整个dom结构抽象成一个js中的object对象，在数据更新的时候diff一下新旧对象，再把object渲染成完整的dom结构  
这个优缺点很明显：
  1. 能保证性能下限，因为不管多少个节点更新，都只会做一次render，但这也是性能瓶颈，因为如果只有一个节点做了更改，整个页面都会进行一次重绘，在一些要求比较高的应用，比如vscode，他们就会直接操作dom，来代替部分虚拟dom的渲染
  2. 兼容性更好，因为全是js的对象来保存dom结构信息，所以兼容性的处理统一由一个render函数处理了，贼拉方便
  3. 不需要操作dom了，会把开发者的注意力集中到处理数据和逻辑上，效率会更高
  4. 因为出现了虚拟dom的渲染方式，所以nodejs做服务端渲染，变得更加方便，不再做模版解析。而且这个也可以跨平台，比如小程序，微信自定义了一种类似html的wxml，在render函数中，修改对应生成的节点类型，就可以兼容到小程序。

![](/note/2019-08-20-11-18-06.png)  
所以更新问题就会被转换成了两颗树的比较问题。标准的diff算法的复杂度O(n^3)，在dom树上，可以做很多优化，最后可以降到O(n)  
主要是：不同类型的元素产生不同的树；同一层级的一组子节点可以通过唯一的key区分
![](/note/2019-08-20-11-18-26.png)  
也就是，只会对相同颜色的dom节点进行比较；如果节点不存在了，该节点和它的子节点都被删除，不做进一步的比较


### diff算法
![](/note/2019-08-20-11-20-42.png)
并不是移动a和它的子节点，而是：createA，createB，createC，deleteA（old）  
抽象完成之后，变成这种结构：
![](/note/2019-08-20-12-53-03.png)  

1. 先比较最外层节点，其实是比较抽象时节点的key和sel，如果这俩都不一样，就直接替换了
2. 上一步如果相同，则会把旧节点的el赋值到新节点上，让它指向同一个对象，保证对对象的修改会同步到新节点上。然后继续比较，如果新旧对象的引用相同，也就是内存地址都相同，就是相同的节点，可以跳过了；如果不同，再比较文本，如果文本相同，比较子节点
3. 子节点的情况再分成：新的有，旧的没有，就在老节点上添加；如果新节点没有，旧的有，就删除；如果都有，做更新
4. ![](/note/2019-08-20-12-54-52.png)
5. 更新过程：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式：
    * 新的start和旧的start，相同时不进行dom移动
    * 新的end和旧的end，相同时不进行dom移动
    * 新的start和旧的end，相同时，说明旧的end跑到start前
    * 新的end和旧的start，相同时，说明旧的start跑到end后
6. 在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。
7. 结束时分成两种
    * oldStartIdx > oldEndIdx：newStartIdx和newEndIdx之间就是新增的了，直接插入
    * newStartIdx > newEndIdx：oldStartIdx和oldEndIdx之间就是需要删除的